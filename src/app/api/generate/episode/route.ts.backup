import { NextResponse } from 'next/server'
import { generateContent } from '@/services/azure-openai'
import { GoogleGenerativeAI } from '@google/generative-ai'
import { NextRequest } from 'next/server'

// Initialize Gemini AI with API key
const getGeminiKey = () => {
  const apiKey = process.env.GEMINI_API_KEY
  if (!apiKey) {
    throw new Error('GEMINI_API_KEY is not configured')
  }
  
  if (apiKey.length < 10) {
    throw new Error('GEMINI_API_KEY is too short, please check the value')
  }
  
  return apiKey
}

const genAI = new GoogleGenerativeAI(getGeminiKey())

// Helper function to safely parse JSON from text that might contain markdown code blocks
const safeParseJSON = (text: string) => {
  try {
    // First, try direct parsing
    return JSON.parse(text)
  } catch (e) {
    // If that fails, look for JSON inside markdown code blocks
    try {
      const jsonMatch = text.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/)
      if (jsonMatch && jsonMatch[1]) {
        return JSON.parse(jsonMatch[1])
      }
    } catch (innerError) {
      console.error("Failed to parse JSON from markdown block", innerError)
    }
    
    // If all parsing attempts fail, create a basic structure
    return {
      episodeNumber: 1,
      script: "INT. LOCATION - DAY\n\nCharacters discuss the situation.\n\nEND SCENE",
      branchingOptions: [
        "Continue the conversation",
        "Leave the location",
        "Change the subject"
      ]
    }
  }
}

// Episode schema for structured output
const episodeSchema = {
  type: "object",
  properties: {
    episodeNumber: { type: "number" },
    script: { type: "string" },
    branchingOptions: {
      type: "array",
      items: { type: "string" }
    }
  }
}

// Generate episode with Azure OpenAI
async function generateEpisodeWithAzure(storyBible: any, episodeNumber: number, previousChoice?: string, userChoices?: any[]) {
  // Construct a detailed system prompt for the episode
  const systemPrompt = `You are an Episode Writer for a series, responsible for creating engaging, 5-minute episodes that fit within a broader narrative framework.
You excel at crafting dynamic scenes, meaningful dialogue, and compelling narrative choices.
Each episode should follow a specific format with a title, synopsis, three scenes in third-person narrative, an episode rundown, and branching choices.
Follow these quality guidelines:

Tone: Maintain consistent tone appropriate to the genre and theme.
Continuity: Ensure each episode logically follows from previous events and choices.
Character Consistency: Reference established character developments and relationships.
Story Coherence: Build upon previous plot threads and user choices.
Pacing: Craft tight, focused scenes appropriate for a 5-minute segment.
Character Development: Show character growth or change through their actions and decisions.
Meaningful Choices: End with branching options that represent genuinely different narrative directions.

Return a single JSON object representing the complete episode in the required format.`;

  // Build narrative context
  const narrativeArcInfo = (storyBible.narrativeArcs || [])
    .filter((arc: any) => {
      const episodes = arc.episodes || [];
      return episodes.some((ep: any) => ep.number === episodeNumber);
    })
    .map((arc: any) => {
      const episode = (arc.episodes || []).find((ep: any) => ep.number === episodeNumber);
      return {
        arcTitle: arc.title,
        arcSummary: arc.summary,
        episodeTitle: episode?.title || `Episode ${episodeNumber}`,
        episodeSummary: episode?.summary || '',
      };
    })[0] || {
      arcTitle: `Arc ${Math.ceil(episodeNumber / 10)}`,
      arcSummary: 'The journey continues...',
      episodeTitle: `Episode ${episodeNumber}`,
      episodeSummary: '',
    };

  // ENHANCED: Build user choice context for story coherence
  let choiceContext = '';
  let characterContext = '';
  let locationContext = '';
  
  if (userChoices && userChoices.length > 0) {
    // Get choices from previous episodes
    const previousChoices = userChoices
      .filter(choice => choice.episodeNumber < episodeNumber)
      .slice(-5) // Last 5 choices for context
      .map(choice => `Episode ${choice.episodeNumber}: "${choice.choiceText}"`)
      .join('\n');
    
    if (previousChoices) {
      choiceContext = `\n\nPREVIOUS USER CHOICES CONTEXT:\n${previousChoices}\nThese choices should influence character relationships, plot development, and available options.`;
    }
  }

  // Include dynamic story bible elements if available
  if (storyBible.newCharacters && storyBible.newCharacters.length > 0) {
    const relevantNewCharacters = storyBible.newCharacters
      .filter((char: any) => char.introducedInEpisode <= episodeNumber)
      .map((char: any) => `${char.name} - ${char.description}`)
      .join('\n');
    
    if (relevantNewCharacters) {
      characterContext = `\n\nNEW CHARACTERS TO CONSIDER:\n${relevantNewCharacters}`;
    }
  }

  if (storyBible.newLocations && storyBible.newLocations.length > 0) {
    const relevantNewLocations = storyBible.newLocations
      .filter((loc: any) => loc.introducedInEpisode <= episodeNumber)
      .map((loc: any) => `${loc.name} - ${loc.description}`)
      .join('\n');
    
    if (relevantNewLocations) {
      locationContext = `\n\nNEW LOCATIONS AVAILABLE:\n${relevantNewLocations}`;
    }
  }

  // Construct the user prompt with the story bible and episode number
  const prompt = `Create Episode ${episodeNumber} of "${storyBible.seriesTitle}" in the required format for a 5-minute episode.

CONTEXT:
${previousChoice ? `In the previous episode, the audience chose: "${previousChoice}"` : 'This is the beginning of the story.'}
Current Narrative Arc: ${narrativeArcInfo.arcTitle}
Arc Summary: ${narrativeArcInfo.arcSummary}
Episode Title: ${narrativeArcInfo.episodeTitle}
Episode Summary: ${narrativeArcInfo.episodeSummary}${choiceContext}${characterContext}${locationContext}

CHARACTERS (Use only the most relevant characters for this episode):
${storyBible.mainCharacters
  .slice(0, 6)
  .map((char: any) => `- ${char.name} (${char.archetype}): ${char.description?.substring(0, 100) || char.arc?.substring(0, 100) || 'No description'}...`)
  .join('\n')}

STORY COHERENCE REQUIREMENTS:
- Reference previous user choices and their consequences when relevant
- Maintain character consistency and development from previous episodes
- Use established locations and characters appropriately
- Build upon plot threads introduced in earlier episodes
- Ensure choices reflect the current story state and character relationships

REQUIRED FORMAT:
1. Episode Title - Create a compelling title that captures the essence of the episode
2. Episode Synopsis - A one or two-line high-level logline describing the episode's hook
3. Scenes - Create 1-8 scenes based on story pacing needs:
   - 1 scene: One comprehensive 700-800 word scene for simple, focused episodes
   - 2 scenes: Two 350-400 word scenes each for episodes with clear two-part structure
   - 3 scenes: Three 230-270 word scenes each for classic three-act structure
   - 4 scenes: Four 175-200 word scenes each for complex multi-part episodes  
   - 5 scenes: Five 140-160 word scenes each for fast-paced, action-heavy episodes
   - 6 scenes: Six 115-130 word scenes each (USE ONLY when absolutely necessary for montages/time passage)
   - 7 scenes: Seven 100-115 word scenes each (USE ONLY when no other structure works)
   - 8 scenes: Eight 85-100 word scenes each (USE ONLY as absolute last resort for rapid montage sequences)

MANDATORY SCENE COUNT REQUIREMENTS - YOU MUST FOLLOW THESE RULES:
${episodeNumber <= 2 
  ? '- THIS EPISODE (1-2): MUST use 1-2 scenes for introduction/setup' 
  : episodeNumber % 4 === 0 
    ? '- THIS EPISODE: MUST use 4-5 scenes for action/complexity' 
    : episodeNumber % 5 === 0 
      ? '- THIS EPISODE: MUST use 2 scenes for focused two-part structure'
      : episodeNumber % 7 === 0
        ? '- THIS EPISODE: MUST use 5 scenes for fast-paced content'
        : '- THIS EPISODE: Use 3 scenes for standard progression'}

CRITICAL SCENE COUNT RULE FOR EPISODE ${episodeNumber}:
- You MUST generate exactly ${
  episodeNumber <= 2 ? '1-2' : 
  episodeNumber % 4 === 0 ? '4-5' : 
  episodeNumber % 5 === 0 ? '2' :
  episodeNumber % 7 === 0 ? '5' : '3'} scenes
- DO NOT use 3 scenes unless this episode specifically requires 3 scenes
- Episode ${episodeNumber} is categorized as: ${
  episodeNumber <= 2 ? 'Introduction Episode (1-2 scenes)' : 
  episodeNumber % 4 === 0 ? 'Action Episode (4-5 scenes)' : 
  episodeNumber % 5 === 0 ? 'Two-Part Episode (2 scenes)' :
  episodeNumber % 7 === 0 ? 'Fast-Paced Episode (5 scenes)' : 'Standard Episode (3 scenes)'}

- Each scene should be a detailed third-person narrative summary
- Adjust individual scene length to maintain ~5 minute total episode duration
- Ensure each scene advances the story and develops characters meaningfully

RESTRICTIONS FOR 6-8 SCENES:
- Use ONLY when the story structure absolutely demands it
- Use ONLY for: montages, memory fragments, rapid time passage, multiple simultaneous perspectives, emergency/crisis scenarios
- Do NOT use for: normal character development, standard plot progression, dialogue scenes
- Always prefer fewer, more substantial scenes when possible
- If considering 6+ scenes, justify why 5 or fewer scenes cannot work

IMPORTANT GUIDELINES:
- All scenes should be detailed, vivid, and written in third-person narrative style
- Each scene should show clear progression of the story and character development
- Choose the optimal number of scenes for the story being told (don't force 3 if 2 or 4 works better)
- Maintain consistent pacing and ensure scenes flow naturally into each other
- Include callbacks to previous episodes/events when appropriate (if Episode ${episodeNumber} > 1)
- Plant subtle foreshadowing for future developments
- Introduce new characters or locations ONLY if the story organically demands it
- Weave in recurring motifs and themes from the story bible
- Reference user choices and their consequences in character interactions and plot developments
- If approaching an arc finale (every 8-12 episodes), consider choices that could lead to entirely new settings or introduce significant new characters for the next arc
- Choices in arc finales should set up potential for: new allies/enemies, unexplored territories, hidden conspiracies, time/dimension shifts, or major character revelations
- Arc finale choices can introduce: new geographic locations, previously unknown characters, alternate dimensions/time periods, secret organizations, or hidden world elements
- These new elements should feel organic to the story and provide fresh narrative possibilities for the next arc
- For major story transitions, one choice should potentially open up a completely new narrative direction
- The branching choices must be meaningful and consequential to the narrative
- Ensure each choice represents a distinctly different path for the story

- When generating episodes that follow major choices, reference and build upon the consequences of previous user decisions
- New characters introduced through choices should have meaningful roles in future episodes
- New locations should become recurring settings that influence the story direction
- Choice consequences should ripple through multiple episodes, not just the immediate next one

Return the episode in this JSON format:
{
  "episodeNumber": ${episodeNumber},
  "episodeTitle": "Title of the episode",
  "synopsis": "One or two sentence synopsis of the episode",
  "scenes": [
    {
      "sceneNumber": 1,
      "content": "Detailed narrative description of scene 1"
    },
    {
      "sceneNumber": 2,
      "content": "Detailed narrative description of scene 2"
    },
    {
      "sceneNumber": 3,
      "content": "Detailed narrative description of scene 3"
    }
  ],
  "rundown": "Paragraph explaining the episode's purpose in the overall story",
  "callbacks": [
    "References to previous episodes/events (if applicable)"
  ],
  "foreshadowing": [
    "Subtle hints about future developments"
  ],
  "newCharacters": [
    "Any new characters introduced (only if story demands it)"
  ],
  "newLocations": [
    "Any new locations introduced (only if story demands it)"
  ],
  "branchingOptions": [
    "First option description",
    "Second option description",
    "Third option description"
  ]
}`;

  try {
    // Generate content using Azure OpenAI with GPT-4.1
    const result = await generateContent(prompt, {
      model: 'gpt-4.1',
      systemPrompt,
      temperature: 0.8,
      maxTokens: 8000
    });
    
    // Try to extract JSON from the response
    let parsedResponse = safeParseJSON(result);
    
    // If we couldn't parse JSON, try to extract just the script and create a structured object
    if (!parsedResponse.episodeNumber) {
      // Look for branching options at the end of the script
      const branchingOptions: string[] = [];
      const scriptLines = result.split('\n');
      let scriptContent = result;
      
      // Check the last 10 lines for branching options
      const potentialOptions: string[] = scriptLines.slice(-10);
      for (const line of potentialOptions) {
        if (line.match(/^[0-9][.)]\s/) || line.match(/^Option [0-9]:/) || line.match(/^[A-C][.)]\s/)) {
          const option = line.replace(/^[0-9A-C][.)]\s|^Option [0-9]:\s*/, '').trim();
          if (option && option.length > 5) {
            branchingOptions.push(option);
          }
        }
      }
      
      // If we found options, remove them from the script
      if (branchingOptions.length > 0) {
        // Trim the script to remove the options section
        const optionIndex = scriptLines.findIndex((line: string) => 
          line.match(/^[0-9][.)]\s/) || 
          line.match(/^Option [0-9]:/) || 
          line.match(/^BRANCHING OPTIONS/) ||
          line.match(/^CHOICES:/) ||
          line.match(/^[A-C][.)]\s/)
        );
        
        if (optionIndex !== -1) {
          scriptContent = scriptLines.slice(0, optionIndex).join('\n').trim();
        }
      }
      
      // Ensure we have at least 3 options
      while (branchingOptions.length < 3) {
        branchingOptions.push(`Option ${branchingOptions.length + 1}`);
      }
      
      // If we have more than 3, trim to 3
      const finalOptions = branchingOptions.slice(0, 3);
      
      parsedResponse = {
        episodeNumber,
        script: scriptContent,
        branchingOptions: finalOptions
      };
    }
    
    console.log('Successfully generated episode with Azure OpenAI');
    return parsedResponse;
  } catch (error) {
    console.error('Error generating episode with Azure OpenAI:', error);
    
    // Try GPT-4o as fallback
    try {
      console.log('Falling back to GPT-4o...');
      const result = await generateContent(prompt, {
        model: 'gpt-4o',
        systemPrompt,
        temperature: 0.8,
        maxTokens: 8000
      });
      
      // Process the response the same way as above
      let parsedResponse = safeParseJSON(result);
      
      // Same extraction logic as above if needed
      if (!parsedResponse.episodeNumber) {
        // (Repeat the code from above for extracting script and options)
        // ...
        
        // Look for branching options at the end of the script
        const branchingOptions: string[] = [];
        const scriptLines = result.split('\n');
        let scriptContent = result;
        
        // Check the last 10 lines for branching options
        const potentialOptions: string[] = scriptLines.slice(-10);
        for (const line of potentialOptions) {
          if (line.match(/^[0-9][.)]\s/) || line.match(/^Option [0-9]:/) || line.match(/^[A-C][.)]\s/)) {
            const option = line.replace(/^[0-9A-C][.)]\s|^Option [0-9]:\s*/, '').trim();
            if (option && option.length > 5) {
              branchingOptions.push(option);
            }
          }
        }
        
        // If we found options, remove them from the script
        if (branchingOptions.length > 0) {
          // Trim the script to remove the options section
          const optionIndex = scriptLines.findIndex((line: string) => 
            line.match(/^[0-9][.)]\s/) || 
            line.match(/^Option [0-9]:/) || 
            line.match(/^BRANCHING OPTIONS/) ||
            line.match(/^CHOICES:/) ||
            line.match(/^[A-C][.)]\s/)
          );
          
          if (optionIndex !== -1) {
            scriptContent = scriptLines.slice(0, optionIndex).join('\n').trim();
          }
        }
        
        // Ensure we have at least 3 options
        while (branchingOptions.length < 3) {
          branchingOptions.push(`Option ${branchingOptions.length + 1}`);
        }
        
        // If we have more than 3, trim to 3
        const finalOptions = branchingOptions.slice(0, 3);
        
        parsedResponse = {
          episodeNumber,
          script: scriptContent,
          branchingOptions: finalOptions
        };
      }
      
      console.log('Successfully generated episode with GPT-4o fallback');
      return parsedResponse;
    } catch (secondError) {
      console.error('Error with GPT-4o fallback:', secondError);
      
      // Fall back to Gemini
      console.log('Falling back to Gemini...');
      return generateEpisodeWithGemini(storyBible, episodeNumber, previousChoice);
    }
  }
}

// Generate episode with Gemini
async function generateEpisodeWithGemini(storyBible: any, episodeNumber: number, previousChoice?: string) {
  // Use the stable mode model from environment variables or default to gemini-2.5-pro
  const geminiModel = process.env.GEMINI_STABLE_MODE_MODEL || 'gemini-2.5-pro';
  const model = genAI.getGenerativeModel({ model: geminiModel });
  
  console.log(`Generating episode with Gemini model: ${geminiModel}`);

  // Build narrative context
  const narrativeArcInfo = (storyBible.narrativeArcs || [])
    .filter((arc: any) => {
      const episodes = arc.episodes || [];
      return episodes.some((ep: any) => ep.number === episodeNumber);
    })
    .map((arc: any) => {
      const episode = (arc.episodes || []).find((ep: any) => ep.number === episodeNumber);
      return {
        arcTitle: arc.title,
        arcSummary: arc.summary,
        episodeTitle: episode?.title || `Episode ${episodeNumber}`,
        episodeSummary: episode?.summary || '',
      };
    })[0] || {
      arcTitle: `Arc ${Math.ceil(episodeNumber / 10)}`,
      arcSummary: 'The journey continues...',
      episodeTitle: `Episode ${episodeNumber}`,
      episodeSummary: '',
    };

  // Construct the prompt
  const prompt = `Create Episode ${episodeNumber} of "${storyBible.seriesTitle}" in the required format for a 5-minute episode.

CONTEXT:
${previousChoice ? `In the previous episode, the audience chose: "${previousChoice}"` : 'This is the beginning of the story.'}
Current Narrative Arc: ${narrativeArcInfo.arcTitle}
Arc Summary: ${narrativeArcInfo.arcSummary}
Episode Title: ${narrativeArcInfo.episodeTitle}
Episode Summary: ${narrativeArcInfo.episodeSummary}

CHARACTERS (Use only the most relevant characters for this episode):
${storyBible.mainCharacters
  .slice(0, 6)
  .map((char: any) => `- ${char.name} (${char.archetype}): ${char.description?.substring(0, 100) || char.arc?.substring(0, 100) || 'No description'}...`)
  .join('\n')}

REQUIRED FORMAT:
1. Episode Title - Create a compelling title that captures the essence of the episode
2. Episode Synopsis - A one or two-line high-level logline describing the episode's hook
3. Scenes - Create 1-8 scenes based on story pacing needs:
   - 1 scene: One comprehensive 700-800 word scene for simple, focused episodes
   - 2 scenes: Two 350-400 word scenes each for episodes with clear two-part structure
   - 3 scenes: Three 230-270 word scenes each for classic three-act structure
   - 4 scenes: Four 175-200 word scenes each for complex multi-part episodes
   - 5 scenes: Five 140-160 word scenes each for fast-paced, action-heavy episodes
   - 6 scenes: Six 115-130 word scenes each (USE ONLY when absolutely necessary for montages/time passage)
   - 7 scenes: Seven 100-115 word scenes each (USE ONLY when no other structure works)
   - 8 scenes: Eight 85-100 word scenes each (USE ONLY as absolute last resort for rapid montage sequences)
4. Episode Rundown - A paragraph explaining the episode's purpose in the overall story, how it sets up what comes next, and why it matters
5. Branching Choices - Three distinct choices tied directly to the action and stakes established in the final scene

DYNAMIC SCENE COUNT SELECTION - VARY TO MATCH EPISODE CONTENT:
- CHOOSE scene count that best serves this specific episode's narrative purpose
- Simple character moments or single conflicts: 1-2 scenes
- Action sequences, revelations, or major developments: 4-5 scenes  
- Complex episodes with multiple plot threads: 4-5 scenes
- Standard story progression: 3 scenes (only if other counts don't fit the content better)
- IMPORTANT: Consider what scene structure will most effectively tell THIS episode's story
- CRITICAL: Only use 6-8 scenes when ABSOLUTELY NECESSARY and NO OTHER approach works
- 6-8 scenes should ONLY be used for: rapid montages, time passage sequences, fragmented memories, or emergency multi-perspective episodes
- Before choosing 6+ scenes, ask: "Can this story be told effectively with 5 or fewer scenes?"
- Each scene should be a detailed third-person narrative summary
- Adjust individual scene length to maintain ~5 minute total episode duration
- Ensure each scene advances the story and develops characters meaningfully

RESTRICTIONS FOR 6-8 SCENES:
- Use ONLY when the story structure absolutely demands it
- Use ONLY for: montages, memory fragments, rapid time passage, multiple simultaneous perspectives, emergency/crisis scenarios
- Do NOT use for: normal character development, standard plot progression, dialogue scenes
- Always prefer fewer, more substantial scenes when possible
- If considering 6+ scenes, justify why 5 or fewer scenes cannot work

IMPORTANT GUIDELINES:
- All scenes should be detailed, vivid, and written in third-person narrative style
- Each scene should show clear progression of the story and character development
- Choose the optimal number of scenes for the story being told (don't force 3 if 2 or 4 works better)
- Maintain consistent pacing and ensure scenes flow naturally into each other
- Include callbacks to previous episodes/events when appropriate (if Episode ${episodeNumber} > 1)
- Plant subtle foreshadowing for future developments
- Introduce new characters or locations ONLY if the story organically demands it
- Weave in recurring motifs and themes from the story bible
- If approaching an arc finale (every 8-12 episodes), consider choices that could lead to entirely new settings or introduce significant new characters for the next arc
- For major story transitions, one choice should potentially open up a completely new narrative direction
- The branching choices must be meaningful and consequential to the narrative
- Ensure each choice represents a distinctly different path for the story

- When generating episodes that follow major choices, reference and build upon the consequences of previous user decisions
- New characters introduced through choices should have meaningful roles in future episodes
- New locations should become recurring settings that influence the story direction
- Choice consequences should ripple through multiple episodes, not just the immediate next one

Please provide your answer in this JSON format:
{
  "episodeNumber": ${episodeNumber},
  "episodeTitle": "Title of the episode",
  "synopsis": "One or two sentence synopsis of the episode",
  "scenes": [
    {
      "sceneNumber": 1,
      "content": "Detailed narrative description of scene 1"
    },
    {
      "sceneNumber": 2,
      "content": "Detailed narrative description of scene 2"
    },
    {
      "sceneNumber": 3,
      "content": "Detailed narrative description of scene 3"
    }
  ],
  "rundown": "Paragraph explaining the episode's purpose in the overall story",
  "callbacks": [
    "References to previous episodes/events (if applicable)"
  ],
  "foreshadowing": [
    "Subtle hints about future developments"
  ],
  "newCharacters": [
    "Any new characters introduced (only if story demands it)"
  ],
  "newLocations": [
    "Any new locations introduced (only if story demands it)"
  ],
  "branchingOptions": [
    "First option description",
    "Second option description",
    "Third option description"
  ]
}`;

  try {
    console.log(`Starting Gemini generation for episode ${episodeNumber}...`);
    const genResult = await model.generateContent(prompt);
    console.log(`Received response from Gemini for episode ${episodeNumber}`);
    const responseText = genResult.response.text();
    
    // Try to parse the response
    const parsedResponse = safeParseJSON(responseText);
    
    // Validate the response structure
    if (!parsedResponse || !parsedResponse.scenes || !Array.isArray(parsedResponse.scenes) || parsedResponse.scenes.length === 0) {
      console.error(`Invalid episode structure from Gemini for episode ${episodeNumber}:`, parsedResponse);
      
      // Try to repair the response if it has script but no scenes
      if (parsedResponse && parsedResponse.script && typeof parsedResponse.script === 'string') {
        console.log(`Attempting to convert script format to scenes for episode ${episodeNumber}`);
        
        // Convert script to scenes format
        return {
          episodeNumber,
          episodeTitle: parsedResponse.episodeTitle || `Episode ${episodeNumber}`,
          synopsis: "An episode that continues the story...",
          scenes: [
            {
              sceneNumber: 1,
              content: `Beginning of the story. ${parsedResponse.script.substring(0, 500)}...`
            },
            {
              sceneNumber: 2,
              content: `The story develops further. ${parsedResponse.script.substring(500, 1000) || "Characters face challenges and make decisions."}`
            },
            {
              sceneNumber: 3,
              content: `The story reaches a decision point. ${parsedResponse.script.substring(1000, 1500) || "Characters must choose how to proceed."}`
            }
          ],
          rundown: "This episode advances the story and presents new challenges.",
          branchingOptions: parsedResponse.branchingOptions || [
            "Continue along the current path",
            "Take a different approach",
            "Explore a new direction"
          ]
        };
      }
      
      // Create a dynamic fallback response with variable scene count
      console.log(`Creating fallback episode structure for episode ${episodeNumber}`);
      
      // Determine dynamic scene count (1-8 based on episode complexity)
      const episodeComplexity = episodeNumber % 8; // Simple heuristic for demo
      let sceneCount;
      let sceneLengthTarget;
      
      if (episodeComplexity <= 1) {
        sceneCount = 1; // Simple episodes
        sceneLengthTarget = 700;
      } else if (episodeComplexity <= 3) {
        sceneCount = 2; // Two-part episodes
        sceneLengthTarget = 350;
      } else if (episodeComplexity <= 5) {
        sceneCount = 3; // Classic three-act (default)
        sceneLengthTarget = 250;
      } else if (episodeComplexity <= 6) {
        sceneCount = 4; // Complex multi-part
        sceneLengthTarget = 180;
      } else {
        sceneCount = 5; // Fast-paced action
        sceneLengthTarget = 150;
      }
      
      const scenes = [];
      for (let i = 1; i <= sceneCount; i++) {
        let sceneContent;
        if (sceneCount === 1) {
          sceneContent = `In this comprehensive scene, the characters from ${storyBible.seriesTitle} face a significant moment that builds upon their previous decision${previousChoice ? ` to ${previousChoice}` : ''}. The story unfolds with detailed character development and meaningful progression as they navigate new challenges and discoveries that will shape their journey forward.`;
        } else if (i === 1) {
          sceneContent = `The episode opens as the characters from ${storyBible.seriesTitle} gather to address the consequences of their previous decision${previousChoice ? ` to ${previousChoice}` : ''}. New developments emerge that will test their resolve.`;
        } else if (i === sceneCount) {
          sceneContent = `The situation reaches a critical decision point. The characters must choose their path forward, with their decision carrying significant weight for the story's direction and their personal growth.`;
        } else {
          sceneContent = `The story develops further as new challenges emerge. The characters must work together, drawing upon their experiences and relationships to navigate the evolving situation.`;
        }
        
        scenes.push({
          sceneNumber: i,
          content: sceneContent
        });
      }
      
      return {
        episodeNumber,
        episodeTitle: `Episode ${episodeNumber}: The Journey Continues`,
        synopsis: `The story of ${storyBible.seriesTitle} continues with new challenges and decisions.`,
        scenes: scenes,
        rundown: `This episode of ${storyBible.seriesTitle} builds on previous events and sets the stage for future developments in the story. The characters' choices will have lasting consequences.`,
        branchingOptions: [
          "Take a bold and risky approach to the situation",
          "Proceed with caution and gather more information",
          "Seek help from allies or mentors before deciding"
        ]
      };
    }
    
    console.log(`Successfully parsed Gemini response for episode ${episodeNumber}`);
    return parsedResponse;
  } catch (error) {
    console.error(`Error generating episode ${episodeNumber} with Gemini:`, error);
    
    // Create a fallback response
    console.log(`Creating fallback episode structure for episode ${episodeNumber} after error`);
    return {
      episodeNumber,
      episodeTitle: `Episode ${episodeNumber}: Continuing the Journey`,
      synopsis: `The story of ${storyBible.seriesTitle} faces unexpected developments.`,
      scenes: [
        {
          sceneNumber: 1,
          content: `The characters from ${storyBible.seriesTitle} continue their journey, reflecting on past events and planning their next steps.`
        },
        {
          sceneNumber: 2,
          content: "New information comes to light that changes the characters' understanding of their situation. They must adapt to these revelations."
        },
        {
          sceneNumber: 3,
          content: "A moment of decision arrives as the characters consider different approaches to their current challenge."
        }
      ],
      rundown: `This episode advances the narrative of ${storyBible.seriesTitle} by introducing new elements and setting up future conflicts.`,
      branchingOptions: [
        "Confront the challenge directly",
        "Look for an alternative solution",
        "Reassess priorities before making a decision"
      ]
    };
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const { storyBible, episodeNumber, previousChoice, userChoices } = body
    
    if (!storyBible || !episodeNumber) {
      return NextResponse.json(
        { error: 'Story bible and episode number are required' },
        { status: 400 }
      )
    }

    console.log(`Generating episode ${episodeNumber} with Azure OpenAI${previousChoice ? ` (previous choice: ${previousChoice})` : ''}`)
    
    // ENHANCED: Pass user choices for story coherence
    const result = await generateEpisodeWithAzure(storyBible, episodeNumber, previousChoice, userChoices)
    
    return NextResponse.json({
      success: true,
      episode: result
    })
    } catch (error) {
    console.error('Error generating episode:', error)
    return NextResponse.json(
      { error: 'Failed to generate episode', details: error instanceof Error ? error.message : 'Unknown error' },
      { status: 500 }
    )
  }
} 