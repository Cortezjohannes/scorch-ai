/**
 * 🚀 PRODUCTION EPISODE GENERATION API ROUTE
 * 
 * Production-safe episode generation with comprehensive monitoring and feature flags.
 * Phase 5: Production Deployment Implementation
 */

import { NextResponse } from 'next/server'
import { NextRequest } from 'next/server'
import { productionEpisodeGenerator, ProductionGenerationRequest } from '@/services/production-episode-generator'
import { featureFlagManager, FeatureFlagContext } from '@/services/production-feature-flags'
import { productionQualityMonitor } from '@/services/production-quality-monitor'
import { productionMonitoringDashboard } from '@/services/production-monitoring-dashboard'
import { logger } from '@/services/console-logger'

// 📊 PRODUCTION API INTERFACES

interface ProductionAPIRequest {
  storyBible: any
  episodeNumber: number
  previousChoice?: string
  userChoices?: any[]
  sessionId?: string
  userId?: string
  enableProductionFeatures?: boolean
  qualityThreshold?: number
}

interface ProductionAPIResponse {
  success: boolean
  episode?: any
  generationMode: string
  qualityScore: number
  processingTime: number
  warnings: string[]
  featureFlagsUsed: string[]
  fallbackReason?: string
  error?: string
  metadata: {
    sessionId: string
    engineMetadata?: any
    systemHealth: any
    featureFlags: any
  }
}

// 🎯 PRODUCTION-SAFE EPISODE GENERATION

export async function POST(request: NextRequest): Promise<NextResponse> {
  const startTime = Date.now()
  let sessionId = ''
  
  try {
    // Parse request
    const body: ProductionAPIRequest = await request.json()
    
    // Generate session ID
    sessionId = body.sessionId || `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
    
    // Start logging session
    logger.startNewSession(`Production Episode ${body.episodeNumber}`)
    console.log(`🚀 PRODUCTION API: Starting episode generation`)
    console.log(`   Session ID: ${sessionId}`)
    console.log(`   Episode: ${body.episodeNumber}`)
    console.log(`   Story: ${body.storyBible?.seriesTitle || 'Unknown'}`)
    
    // Build feature flag context
    const userAgent = request.headers.get('user-agent') || ''
    const ipAddress = request.headers.get('x-forwarded-for') || 
                     request.headers.get('x-real-ip') || 
                     'unknown'
    
    const flagContext: FeatureFlagContext = {
      userId: body.userId,
      sessionId,
      userAgent,
      ipAddress,
      isBetaTester: body.enableProductionFeatures === true,
      customAttributes: {
        episodeNumber: body.episodeNumber,
        hasStoryBible: !!body.storyBible
      }
    }
    
    // Check active feature flags
    const activeFlags = checkActiveFeatureFlags(flagContext)
    console.log(`🎛️ Active Feature Flags: ${activeFlags.join(', ')}`)
    
    // Validate request
    const validation = validateProductionRequest(body)
    if (!validation.valid) {
      return NextResponse.json({
        success: false,
        error: `Invalid request: ${validation.errors.join(', ')}`,
        generationMode: 'none',
        qualityScore: 0,
        processingTime: Date.now() - startTime,
        warnings: [],
        featureFlagsUsed: activeFlags,
        metadata: {
          sessionId,
          systemHealth: productionQualityMonitor.getSystemHealth(),
          featureFlags: getFeatureFlagStatus(activeFlags)
        }
      }, { status: 400 })
    }
    
    // Check system health
    const systemHealth = productionQualityMonitor.getSystemHealth()
    if (systemHealth.status === 'CRITICAL') {
      console.log(`🚨 PRODUCTION API: System health critical, using emergency mode`)
      return handleEmergencyMode(body, sessionId, startTime, activeFlags)
    }
    
    // Build production generation request
    const generationRequest: ProductionGenerationRequest = {
      storyBible: body.storyBible,
      episodeNumber: body.episodeNumber,
      previousChoice: body.previousChoice,
      userChoices: body.userChoices,
      sessionId,
      userId: body.userId,
      featureFlags: activeFlags,
      qualityThreshold: body.qualityThreshold || 7.0,
      maxProcessingTime: 90000 // 90 seconds max
    }
    
    // Generate episode using production-safe system
    console.log(`🚀 PRODUCTION API: Generating episode with production safety...`)
    const result = await productionEpisodeGenerator.generateEpisodeWithProductionSafety(generationRequest)
    
    const processingTime = Date.now() - startTime
    
    // Update feature flag metrics
    updateFeatureFlagMetrics(activeFlags, result.success, result.qualityScore, processingTime)
    
    // Log successful generation
    console.log(`✅ PRODUCTION API: Episode generation completed`)
    console.log(`   Generation Mode: ${result.generationMode}`)
    console.log(`   Quality Score: ${result.qualityScore}/10`)
    console.log(`   Processing Time: ${processingTime}ms`)
    console.log(`   Warnings: ${result.warnings.length}`)
    
    // Build response
    const response: ProductionAPIResponse = {
      success: result.success,
      episode: result.episode,
      generationMode: result.generationMode,
      qualityScore: result.qualityScore,
      processingTime,
      warnings: result.warnings,
      featureFlagsUsed: activeFlags,
      fallbackReason: result.fallbackReason,
      metadata: {
        sessionId,
        engineMetadata: result.engineMetadata,
        systemHealth,
        featureFlags: getFeatureFlagStatus(activeFlags)
      }
    }
    
    return NextResponse.json(response)
    
  } catch (error) {
    const processingTime = Date.now() - startTime
    console.error('❌ PRODUCTION API: Critical error in episode generation:', error)
    
    // Log error for monitoring
    try {
      await productionQualityMonitor.assessEpisodeQuality(
        { title: 'Error Episode', scenes: [] },
        { seriesTitle: 'Unknown' },
        sessionId,
        `error_${Date.now()}`,
        processingTime
      )
    } catch (logError) {
      console.error('Failed to log error episode:', logError)
    }
    
    // Return error response
    const errorResponse: ProductionAPIResponse = {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error occurred',
      generationMode: 'error',
      qualityScore: 0,
      processingTime,
      warnings: ['Critical system error occurred'],
      featureFlagsUsed: [],
      metadata: {
        sessionId,
        systemHealth: productionQualityMonitor.getSystemHealth(),
        featureFlags: {}
      }
    }
    
    return NextResponse.json(errorResponse, { status: 500 })
  }
}

// 🎛️ FEATURE FLAG CHECKING

function checkActiveFeatureFlags(context: FeatureFlagContext): string[] {
  const flags = [
    'complete_context',
    'high_temperature', 
    'enhanced_fallbacks',
    'production_monitoring'
  ]
  
  // Check comprehensive engines flag
  if (featureFlagManager.isFeatureEnabled('comprehensive_engines', context)) {
    flags.push('comprehensive_engines')
  }
  
  // Check genre engines flag
  if (featureFlagManager.isFeatureEnabled('genre_engines', context)) {
    flags.push('genre_engines')
  }
  
  // Check beta features for beta testers
  if (featureFlagManager.isFeatureEnabled('beta_features', context)) {
    flags.push('beta_features')
  }
  
  return flags.filter(flag => featureFlagManager.isFeatureEnabled(flag, context))
}

// ✅ REQUEST VALIDATION

function validateProductionRequest(body: ProductionAPIRequest): { valid: boolean, errors: string[] } {
  const errors: string[] = []
  
  if (!body.storyBible) {
    errors.push('storyBible is required')
  }
  
  if (!body.episodeNumber || body.episodeNumber < 1) {
    errors.push('Valid episodeNumber is required')
  }
  
  if (body.qualityThreshold && (body.qualityThreshold < 0 || body.qualityThreshold > 10)) {
    errors.push('qualityThreshold must be between 0 and 10')
  }
  
  // Validate story bible structure
  if (body.storyBible && typeof body.storyBible === 'object') {
    if (!body.storyBible.seriesTitle) {
      errors.push('storyBible.seriesTitle is required')
    }
    
    if (!body.storyBible.premise) {
      errors.push('storyBible.premise is required')
    }
    
    if (!body.storyBible.mainCharacters || !Array.isArray(body.storyBible.mainCharacters)) {
      errors.push('storyBible.mainCharacters array is required')
    }
  }
  
  return {
    valid: errors.length === 0,
    errors
  }
}

// 🚨 EMERGENCY MODE HANDLING

async function handleEmergencyMode(
  body: ProductionAPIRequest, 
  sessionId: string, 
  startTime: number,
  activeFlags: string[]
): Promise<NextResponse> {
  console.log(`🆘 PRODUCTION API: Entering emergency mode`)
  
  try {
    // Create basic emergency episode
    const emergencyEpisode = {
      episodeNumber: body.episodeNumber,
      title: `Episode ${body.episodeNumber}`,
      synopsis: `An episode of ${body.storyBible?.seriesTitle || 'the series'} continues the story during system recovery.`,
      scenes: [
        {
          sceneNumber: 1,
          title: "Story Continuation",
          content: `The story of ${body.storyBible?.seriesTitle || 'our characters'} continues as they navigate new challenges and developments. Through meaningful dialogue and character interaction, the narrative progresses while maintaining the established tone and relationships.`
        }
      ],
      branchingOptions: [
        {
          id: 1,
          text: "Continue with current storyline",
          description: "Proceed with the established narrative direction",
          isCanonical: true
        },
        {
          id: 2, 
          text: "Explore character relationships",
          description: "Focus on character development and relationships",
          isCanonical: false
        },
        {
          id: 3,
          text: "Introduce new elements",
          description: "Add new story elements or plot developments",
          isCanonical: false
        }
      ],
      episodeRundown: "Emergency mode episode maintaining story continuity during system recovery."
    }
    
    const processingTime = Date.now() - startTime
    
    // Log emergency episode
    await productionQualityMonitor.assessEpisodeQuality(
      emergencyEpisode,
      body.storyBible,
      sessionId,
      `emergency_${Date.now()}`,
      processingTime
    )
    
    const response: ProductionAPIResponse = {
      success: true,
      episode: emergencyEpisode,
      generationMode: 'emergency_mode',
      qualityScore: 5.0, // Basic quality for emergency mode
      processingTime,
      warnings: ['System in emergency mode - basic episode generated'],
      featureFlagsUsed: activeFlags,
      fallbackReason: 'System health critical - emergency mode activated',
      metadata: {
        sessionId,
        systemHealth: productionQualityMonitor.getSystemHealth(),
        featureFlags: getFeatureFlagStatus(activeFlags)
      }
    }
    
    return NextResponse.json(response)
    
  } catch (error) {
    console.error('❌ PRODUCTION API: Emergency mode failed:', error)
    
    const response: ProductionAPIResponse = {
      success: false,
      error: 'System unavailable - emergency mode failed',
      generationMode: 'system_failure',
      qualityScore: 0,
      processingTime: Date.now() - startTime,
      warnings: ['Critical system failure'],
      featureFlagsUsed: activeFlags,
      metadata: {
        sessionId,
        systemHealth: productionQualityMonitor.getSystemHealth(),
        featureFlags: {}
      }
    }
    
    return NextResponse.json(response, { status: 503 })
  }
}

// 📊 FEATURE FLAG METRICS UPDATE

function updateFeatureFlagMetrics(
  flags: string[], 
  success: boolean, 
  quality: number, 
  processingTime: number
): void {
  for (const flag of flags) {
    featureFlagManager.updateFeatureMetrics(
      flag,
      true, // requested
      true, // enabled (since we're using it)
      success,
      quality,
      processingTime
    )
  }
}

// 🎛️ GET FEATURE FLAG STATUS

function getFeatureFlagStatus(activeFlags: string[]): Record<string, any> {
  const status: Record<string, any> = {}
  
  for (const flag of activeFlags) {
    const metrics = featureFlagManager.getFlagMetrics(flag)
    status[flag] = {
      enabled: true,
      metrics: metrics ? {
        usageCount: metrics.enabledRequests,
        successRate: Math.round((1 - metrics.errorRate) * 100),
        averageQuality: Math.round(metrics.averageQuality * 100) / 100
      } : null
    }
  }
  
  return status
}

// 📊 MONITORING ENDPOINTS

export async function GET(request: NextRequest): Promise<NextResponse> {
  const { searchParams } = new URL(request.url)
  const endpoint = searchParams.get('endpoint')
  
  try {
    switch (endpoint) {
      case 'health':
        return NextResponse.json({
          systemHealth: productionQualityMonitor.getSystemHealth(),
          uptime: productionQualityMonitor.getCurrentMetrics().uptimePercentage,
          activeAlerts: productionQualityMonitor.getActiveAlerts().length
        })
        
      case 'metrics':
        return NextResponse.json(productionMonitoringDashboard.getDashboardMetrics())
        
      case 'flags':
        return NextResponse.json({
          activeFlags: featureFlagManager.getActiveFlags(),
          rolloutStatus: featureFlagManager.getRolloutStatus(),
          metrics: featureFlagManager.getAllMetrics()
        })
        
      case 'alerts':
        return NextResponse.json({
          active: productionQualityMonitor.getActiveAlerts(),
          recent: productionQualityMonitor.getRecentLogs(20)
        })
        
      case 'report':
        const report = productionMonitoringDashboard.generateHealthReport()
        return NextResponse.json({ report })
        
      default:
        return NextResponse.json({
          available_endpoints: [
            'health - System health status',
            'metrics - Complete dashboard metrics', 
            'flags - Feature flag status',
            'alerts - Active alerts and recent logs',
            'report - Comprehensive health report'
          ]
        })
    }
  } catch (error) {
    console.error('❌ Monitoring endpoint error:', error)
    return NextResponse.json({
      error: 'Monitoring endpoint failed',
      message: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 })
  }
}

// 🚀 PRODUCTION DEPLOYMENT STATUS

console.log('🚀 PRODUCTION EPISODE GENERATION API LOADED')
console.log('   ✅ Production safety wrappers enabled')
console.log('   ✅ Feature flag system active')
console.log('   ✅ Quality monitoring integrated')
console.log('   ✅ Emergency fallback procedures ready')
console.log('   ✅ Comprehensive monitoring dashboard active')
console.log('')
console.log('🎯 PRODUCTION SUCCESS CRITERIA:')
console.log('   • 99.5%+ system uptime and reliability')
console.log('   • 8.0+/10 quality scores consistently maintained')
console.log('   • 90%+ engine success rate in production')
console.log('   • Emergency rollback procedures tested and ready')
console.log('   • Real-time monitoring and alerting operational')
console.log('')
console.log('🔥 PHASE 5 PRODUCTION DEPLOYMENT: READY FOR CINEMATIC EXCELLENCE!')
